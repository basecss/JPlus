/** * @author  *//** * 为控件提供按控件定位的方法。 * @interface
 */var IAlignedControl = (function(){		var setter1 = {						l: function (ctrlSize, targetSize, targetPosition, documentSize, documentPosition, offset, ctrl) {				var x = targetPosition.x - ctrlSize.x - offset;				if(x <= documentPosition.x) {					x = setter1.r(ctrlSize, targetSize, targetPosition, documentSize, documentPosition, offset, ctrl, false);				}								return x;			},						r: function (ctrlSize, targetSize, targetPosition, documentSize, documentPosition, offset, ctrl, checkOutOfRange) {				var x = targetPosition.x + targetSize.x + offset;				if(x + ctrlSize.x >= documentPosition.x + documentSize.x) {					x = checkOutOfRange !== false ? setter1.l(ctrlSize, targetSize, targetPosition, documentSize, documentPosition, offset, ctrl) : documentPosition.x;				}								return x;			},						t: function (ctrlSize, targetSize, targetPosition, documentSize, documentPosition, offset, ctrl) {				var y = targetPosition.y - ctrlSize.y - offset;				if(y <= documentPosition.y) {					y = setter1.b(ctrlSize, targetSize, targetPosition, documentSize, documentPosition, offset, ctrl, false);				}								return y;			},						b: function (ctrlSize, targetSize, targetPosition, documentSize, documentPosition, offset, ctrl, checkOutOfRange) {				var y = targetPosition.y + targetSize.y + offset;				if(y + ctrlSize.y >= documentPosition.y + documentSize.y) {					if(checkOutOfRange === false) {						ctrl.onOverflowY(documentSize.y);						y = documentPosition.y;					} else {						y = setter1.t(ctrlSize, targetSize, targetPosition, documentSize, documentPosition, offset, ctrl);					}				}								return y;			}					},				setter2 = {					l: function (ctrlSize, targetSize, targetPosition, documentSize, documentPosition, offset, ctrl, checkOutOfRange) {				var x = targetPosition.x + offset;				if(x <= documentPosition.x) {					x = checkOutOfRange !== false ? setter2.r(ctrlSize, targetSize, targetPosition, documentSize, documentPosition, offset, ctrl) : documentPosition.x;				}								return x;			},						r: function (ctrlSize, targetSize, targetPosition, documentSize, documentPosition, offset, ctrl) {				var x = targetPosition.x + targetSize.x - ctrlSize.x - offset;				if(x <= documentPosition.x) {					x = setter2.l(ctrlSize, targetSize, targetPosition, documentSize, documentPosition, offset, ctrl, false);				}								return x;			},						t: function (ctrlSize, targetSize, targetPosition, documentSize, documentPosition, offset, ctrl) {				var y = targetPosition.y + offset;				if(y <= documentPosition.y) {					if(checkOutOfRange === false) {						ctrl.onOverflowY(documentSize.y);						y = documentPosition.y;					} else {						y = setter2.b(ctrlSize, targetSize, targetPosition, documentSize, documentPosition, offset, ctrl);					}				}								return y;			},						b: function (ctrlSize, targetSize, targetPosition, documentSize, documentPosition, offset, ctrl) {				var y = targetPosition.y + targetSize.y - ctrlSize.y - offset;				if(y <= documentPosition.y) {					y = setter2.t(ctrlSize, targetSize, targetPosition, documentSize, documentPosition, offset, ctrl);				}								return y;			}					},				setter = {			rb: [setter1.r, setter2.b],			rt: [setter1.r, setter2.t],			lt: [setter1.l, setter2.t],			lb: [setter1.l, setter2.b],			br: [setter2.r, setter1.b],			tr: [setter2.r, setter1.t],			tl: [setter2.l, setter1.t],			bl: [setter2.l, setter1.b],					};		return {				/**		 * 基于某个控件，设置当前控件的位置。改函数让控件显示都目标的右侧。		 * @param {Controls} ctrl 目标的控件。		 * @param {String} align 设置的位置。如 lt rt 。		 * @param {Number} offsetX 偏移的X大小。		 * @param {Number} offsetY 偏移的y大小。		 */		realign: function (ctrl, align,  offsetX, offsetY) {			var ctrlSize = this.getSize(),				targetSize = ctrl.getSize(),				targetPosition = ctrl.getPosition(),				documentSize = document.getSize(),				documentPosition = document.getPosition();							assert(!align || align in setter, "IAlignedControl.prototype.realign(ctrl, align,  offsetX, offsetY): {align} 必须是 l r 和 t b 的组合。如 lt", align);							align = setter[align] || setter.rt;							this.setPosition(				align[0](ctrlSize, targetSize, targetPosition, documentSize, documentPosition, offsetX || 0, this),				align[1](ctrlSize, targetSize, targetPosition, documentSize, documentPosition, offsetY || 0, this)			);		},		onOverflowY: Function.empty	};})()  ;