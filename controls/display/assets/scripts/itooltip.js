/** * @author  */var IToolTip = {		/**	 * 当指针在具有指定工具提示文本的控件内保持静止时，工具提示保持可见的时间期限。-1表示不自动隐藏。 0 表示始终不显示。	 * @type Number	 */	autoDelay: -1,		/**	 * 工具提示显示之前经过的时间。	 * @type Number	 */	initialDelay: 1000,		/**	 * 指针从一个控件移到另一控件时，必须经过多长时间才会出现后面的工具提示窗口。	 * @type Number	 */	reshowDelay: 100,		duration: -1,		getArrowType: function(){		return 'top';	},		getArrowSize: function(){		return {			x: 0,			y: 0			};	},		getArrowOffset: function(){		return 0;	},		showAt: function(x, y){		if(this.autoDelay) {			this.show(this.duration, this.onShow, 'opacity');			this.setPosition(x, y);		}				return this;	},		showBy: function(ctrl, offsetY, offsetX){		var targetPosition = ctrl.getPosition(),			targetSize = ctrl.getSize(),			arrowOffset = this.getArrowOffset(),			arrowSize = this.getArrowSize();		offsetY = offsetY || 0;		offsetX = offsetX || 0;		switch(this.getArrowType()){			case 'top':				offsetX -= arrowOffset - arrowSize.x / 2;				offsetY += targetSize.y + arrowSize.y;				break;			case 'left':				offsetX += targetSize.x + arrowSize.x;				offsetY += arrowOffset + arrowSize.y / 2;				break;			case 'right':				offsetX -= arrowSize.x;				offsetY += arrowOffset + arrowSize.y / 2;				break;			case 'bottom':				offsetX -= arrowOffset - arrowSize.x / 2;				offsetY -= arrowSize.y;				break;		}						return this.showAt(targetPosition.x + offsetX, targetPosition.y + offsetY);	},		/**	 * 设置某个控件工具提示。	 */	setToolTip: function(ctrl, caption){		ctrl.on('mouseover', function(){			var me = this;			if(me.timer)				clearTimeout(me.timer);			if(me.initialDelay >= 0){				me.timer = setTimeout(function(){					me.timer = 0;					if(caption)						me.setText(caption);					me.showBy(ctrl);				}, me.initialDelay);			}		}, this);				ctrl.on('mouseout', this.close, this);			},		close: function(){		var me = this;		if(me.timer) {			clearTimeout(me.timer);			me.timer = 0;		}		me.hide(me.duration, this.onHide, 'opacity');	},		onHide: Function.empty,		onShow: function(x, y){				if(this.autoDelay > 0) {			me.timer = setTimeout(Function.bind(this.hide, this), this.autoDelay);		}			}	};